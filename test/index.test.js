import {Simple, Tag, encode} from 'cbor2';
import {hexToU8, u8toHex} from 'cbor2/utils';
import assert from 'node:assert/strict';
import {parseEDN} from '../lib/index.js';
// eslint-disable-next-line n/no-unsupported-features/node-builtins
import test from 'node:test';

test('index', () => {
  for (const [str, expected] of [
    ['1', 1],
    ['-0', -0],
    ['1.125', 1.125],
    ['Infinity', Infinity],
    ['-Infinity', -Infinity],
    ['NaN', NaN],
    ['/ A zero! / 0', 0],
    ['# A zero!\n0', 0],
    ['{}', {}],
    ['true', true],
    ['false', false],
    ['null', null],
    ['undefined', undefined],
    ['{"a": true, "b": false}', {a: true, b: false}],
    ['{1: 0, 2: 1, 3: 2}', new Map([[1, 0], [2, 1], [3, 2]])],
    ["2(h'02')", 2n],
    ['simple(0)', new Simple(0)],
    // ['simple(20)', false],
    ['[]', []],
    ['[ ]', []],
    ['[0]', [0]],
    ['[0, 1]', [0, 1]],
    ['[0, 1, 2,]', [0, 1, 2]],
    ['[0, 1, 2, ]', [0, 1, 2]],
    ['"foo"', 'foo'],
    ['"foo\\"\\b\\f\\r\\n\\t\\\\\\/"', 'foo"\x08\x0c\r\n\t\\/'],
    ['"E\\u0308"', 'E\u0308'],
    ['"E\\u{0308}"', 'E\u0308'],
    ['"E\\u{308}"', 'E\u0308'],
    ['"\u{1F4A9}"', '\u{1F4A9}'],
    ['"\u{01F4A9}"', '\u{1F4A9}'],
    ['"\u{001F4A9}"', '\u{1F4A9}'],
    ['"\u{0001F4A9}"', '\u{1F4A9}'],
    ['"\\u{000061}"', 'a'],
    ['"\\u{1F4A9}"', '\u{1F4A9}'],
    ['"\\u{10ffff}"', '\u{10ffff}'],
    ['"\\u{10fff}"', '\u{10fff}'],
    ['"\\u{9000}"', '\u{9000}'],
    ['"\\u{a000}"', '\u{a000}'],
    ['"\\u{d000}"', '\u{d000}'],
    ['"\\u{d00}"', '\u{d00}'],
    ['"\\uD83D\\uDCA9"', '\u{1F4A9}'],
    ['"foo" + "bar"', 'foobar'],
    ["'foo'", 'foo'],
    ["'foo' + 'bar'", 'foobar'],
    ['"\'"', "'"],
    ["h'02'", new Uint8Array([2])],
    ["b64'AgM='", new Uint8Array([2, 3])],
    ["b64'_w'", new Uint8Array([255])],
    [`\
98([<< {/alg/ 1: -7 /ECDSA 256/} >>, # == h'a10126'
    ...                              # rest elided here
])`, new Tag(98, [hexToU8('a10126'), '...'])],
    ["zzz'fo\\to'", {type: 'app-string', prefix: 'zzz', str: 'fo\to'}],
    ["zzz'fo\\'o' + zzz'bar'", {type: 'app-string', prefix: 'zzz', str: "fo'obar"}],
    ["ZZZ'foo' + yyy'b\"ar'", [
      {type: 'app-string', prefix: 'ZZZ', str: 'foo'},
      {type: 'app-string', prefix: 'yyy', str: 'b"ar'},
    ]],
    ['""_', ''],
    ['(_ "foo")', 'foo'],
    ['(_ "foo" "bar")', 'foobar'],
    ['(_ "foo" "bar" "baz")', 'foobarbaz'],
    ['2_i', new Number(2)],
    ['2_0', new Number(2)],
    ['2_1', new Number(2)],
    ['2_2', new Number(2)],
    ['2_3', new Number(2)],
    ['2.0_1', new Number(2)],
    ['2.0_2', new Number(2)],
    ['2.0_3', new Number(2)],
    ['0o777', 0o777],
    ['0b111', 0b111],
    ['0x4c', 0x4c],
    ['0x4Cp16', 0x4c00],
    ['0x4C.abp16', 0x4cab],
    ['0x.4p4', 0x4],
    ['-0x.4p4', -0x4],
    ['-0x4C.abp16', -0x4cab],
    ['+0x.4p4', 0x4],
    ['+0x4C.abp16', 0x4cab],
    ['41.', 41],
    ['41.1', 41.1],
    ['41.12', 41.12],
    ['41.123', 41.123],
    ['.1', 0.1],
    ['.12', 0.12],
    ['1e2', 100],
    ['1e-2', 0.01],
  ]) {
    assert.deepEqual(parseEDN(str), expected, str);
  }
});

test('encoding', () => {
  for (const [str, expected] of [
    ['256_3(1_2)', 'db00000000000001001a00000001'],
    ['256_2(-1.125_2)', 'da00000100fabf900000'],
    ['255_1(-1_i)', 'd900ff20'],
    ['[_i 1, 2]', '820102'],
    ['[_0 1, 2]', '98020102'],
    ['[_1 1, 2]', '9900020102'],
    ['[_2 1, 2]', '9a000000020102'],
    ['[_3 1, 2]', '9b00000000000000020102'],
    ['{_i "a": 1, "b": 2}', 'a2616101616202'],
    ['{_0 "a": 1, "b": 2}', 'b802616101616202'],
    ['{_1 "a": 1, "b": 2}', 'b90002616101616202'],
    ['{_2 "a": 1, "b": 2}', 'ba00000002616101616202'],
    ['{_3 "a": 1, "b": 2}', 'bb0000000000000002616101616202'],
    ['"foo"_i', '63666f6f'],
  ]) {
    assert.deepEqual(u8toHex(encode(parseEDN(str))), expected, str);
  }
});

test('failures', () => {
  for (const invalid of [
    '',
    ' ',
    '  ',
    '   ',
    '   / foo /',
    '   / foo! / ',
    '   / foo\uFBC2 /  ',
    '   / foo\u{1F4A9} /   / bar /',
    '   / foo /   / bar / ',
    '   / foo /   / bar /  ',
    '/ foo\uD83D /',
    '//',
    '/',
    '#foo',
    '#foo\n',
    '#',
    '#\n',
    '#\u{1F4A9}\n',
    '#\x00\n',
    '#\t\r\uFBC2',
    '#\uD83D',
    '[',
    '[ ',
    '[1, 2',
    '[1, 2,',
    '[1, 2, ',
    '2(',
    '2(2',
    'simple(',
    'simple(0',
    'simple(0 ',
    '"',
    '"foo',
    '"foo\x00"',
    '"foo\\;"',
    '"foo" +',
    '"foo" + "',
    '"foo" + "ba',
    '(_',
    '(_ "foo"',
    '{',
    '{1',
    '{1:',
    '0x',
    '0b',
    '0o',
    '0x4cp',
    '0x4c.p',
    '0x.',
    '0x.1',
    '0x.1p',
    '1e',
    '1e-',
    "h'",
    '<<',
    '<< 2',
    '<< {',
    '<< 2 {',
    '<< 2 { >>',
    '"\uDCA9"',
    '"\uD83D"',
    '"\\uDCA9"',
    '"\\uD83D"',
    '"\\uD83D\\"',
    '"\\uD83D\\u"',
    '"\\uD83D\\uDD0"',
    '"\\uD83D\\uD000"',
    // '"\\uD83D\\uDD000"',
    // '"\\ud9000"',
    '"\\ud90"',
    '"\\u{"',
    '"\\u{0"',
    '"\\u{03"',
    "z'\\;'",
    '2.0_a',
    '2_a',
    '0x18_i',
  ]) {
    assert.throws(() => parseEDN(invalid), invalid);
  }
});

